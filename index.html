<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>F-4E RWR PRF Sound Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Favicon -->
    <link rel="icon" href="/F-4E-RWR-PRF-Library/handoff_favicon.ico" type="image/x-icon" />
    <link rel="icon" href="/F-4E-RWR-PRF-Library/handoff_favicon.png" type="image/png" />
    <!-- Apple touch icon -->
    <link rel="apple-touch-icon" href="/F-4E-RWR-PRF-Library/handoff_favicon.png" />

    <!-- Open Graph Preview -->
    <meta property="og:title" content="F-4E RWR PRF Sound Player" />
    <meta
      property="og:description"
      content="Listen and learn the RWR PRF tones from the DCS Heatblur F-4E Phantom module."
    />
    <meta
      property="og:image"
      content="https://officialdsplayer.github.io/F-4E-RWR-PRF-Library/handoff_icon.jpg"
    />
    <meta property="og:url" content="https://officialdsplayer.github.io/F-4E-RWR-PRF-Library/" />
    <meta property="og:type" content="website" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="F-4E RWR PRF Sound Player" />
    <meta
      name="twitter:description"
      content="Listen and learn the RWR PRF tones from the DCS Heatblur F-4E Phantom module."
    />
    <meta
      name="twitter:image"
      content="https://officialdsplayer.github.io/F-4E-RWR-PRF-Library/handoff_icon.jpg"
    />

    <style>
      :root {
        --bg-color: #f5f5f5;
        --text-color: #000;
        --card-bg: #fff;
        --card-text: #000;
        --highlight: #666;
      }

      [data-theme="dark"] {
        --bg-color: #121212;
        --text-color: #f0f0f0;
        --card-bg: #1e1e1e;
        --card-text: #f0f0f0;
        --highlight: #aaa;
      }

      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        transition: background-color 0.3s, color 0.3s;
      }
      h1,
      h2,
      h3,
      h4 {
        text-align: center;
        margin-bottom: 10px;
      }
      .controls {
        text-align: center;
        margin: 20px 0;
      }
      .audio-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
        transition: transform 0.4s ease, opacity 0.4s ease;
        transform-origin: top;
        opacity: 1;
        transform: scaleY(1);
      }

      .audio-grid.collapsed {
        transform: scaleY(0);
        opacity: 0;
        pointer-events: none;
      }

      .audio-card {
        background: var(--card-bg);
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: background 0.3s;
      }
      .file-name {
        font-weight: bold;
        margin-bottom: 5px;
        text-align: center;
        font-size: 1rem;
        color: var(--card-text);
      }
      .file-description {
        font-size: 0.9em;
        text-align: center;
        color: var(--highlight);
        margin-bottom: 8px;
      }
      .button-group {
        display: flex;
        gap: 10px;
      }
      button {
        padding: 8px 14px;
        font-size: 14px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      .play-button {
        background-color: #4caf50;
        color: white;
      }
      .stop-button {
        background-color: #f44336;
        color: white;
      }
      .global-button {
        background-color: #2196f3;
        color: white;
        margin: 5px;
      }

      .play-button:active {
        background-color: #388e3c; /* darker green */
      }
      .play-button.loading {
        background-color: #81c784; /* light green */
        color: black;
        animation: pulse 1.2s infinite;
      }

      .stop-button:active {
        background-color: #c62828; /* darker red */
      }

      .global-button:active {
        background-color: #1976d2; /* darker blue */
      }
      .global-button.loading {
        background-color: #81c784;
        color: black;
        animation: pulse 1.2s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0px rgba(255, 202, 40, 0.4);
        }
        50% {
          box-shadow: 0 0 12px rgba(255, 202, 40, 0.9);
        }
        100% {
          box-shadow: 0 0 0px rgba(255, 202, 40, 0.4);
        }
      }

      .play-button.active {
        background-color: #ffca28; /* amber */
        color: black;
        animation: pulse 1.2s infinite;
      }

      .global-button.active {
        background-color: #ffca28;
        color: black;
        animation: pulse 1.2s infinite;
      }

      .volume-control {
        margin-top: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }
      input[type="range"] {
        width: 200px;
      }
      .group-title {
        font-size: 1.5em;
        margin: 30px 0 10px;
        text-align: center;
        cursor: pointer;
        user-select: none;
      }
      .collapsed {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>F-4E RWR PRF Sound Player</h1>
    <hr class="solid" />
    <h2>By DSplayer</h2>
    <h2>Using sounds from the DCS Heatblur F-4E Module</h2>
    <h3>!!Highly WIP!! Last updated 2025-04-29 (using DCS 2.9.15.9599)</h3>
    <h4><b>**DO NOT PRESS PLAY ALL UNLESS YOUR VOLUME IS VERY LOW**</b></h4>

    <div class="controls">
      <button class="global-button" onclick="playAll()">Play All</button>
      <button class="global-button" onclick="stopAll()">Stop All</button>
      <button class="global-button" onclick="toggleDarkMode()">Toggle Dark Mode</button>
      <div class="volume-control">
        <label for="volume-slider">Volume:</label>
        <input type="range" id="volume-slider" min="0" max="100" value="100" />
      </div>
    </div>

    <div class="controls">
      <input
        type="text"
        id="search-input"
        placeholder="Search sounds..."
        style="
          padding: 8px 14px;
          width: 300px;
          font-size: 14px;
          border-radius: 5px;
          border: 1px solid #ccc;
          margin-bottom: 0px;
        "
      />
    </div>

    <div class="controls">
      <button class="global-button" onclick="expandAllGroups()">Expand All Groups</button>
      <button class="global-button" onclick="collapseAllGroups()">Collapse All Groups</button>
    </div>

    <h4>
      This site is intended to help users learn and memorize what the PRF tones for radars for the
      ALR-46's Handoff mode. If you have any suggestions, please post them in the
      <a href="https://github.com/OfficialDSplayer/F-4E-RWR-PRF-Library/issues"
        >GitHub Issues page</a
      >.
    </h4>

    <div
      id="progress-container"
      style="height: 6px; background: #ddd; width: 100%; margin-top: 10px"
    >
      <div
        id="progress-bar"
        style="height: 100%; width: 0%; background-color: #2196f3; transition: width 0.3s"
      ></div>
    </div>

    <div id="audio-list">Loading sounds...</div>
    <!-- <div id="audio-list">
      <div style="text-align: center; font-size: 1.1rem">Loading sounds...</div>
    </div> -->

    <script>
      let playingSources = [];
      let audioContext;
      let gainNode;
      let soundBuffers = {};
      let groupsData = {};
      let collapsedGroups = JSON.parse(localStorage.getItem("collapsedGroups") || "[]");
      let soundMeta = [];
      const cancelledLoads = new Set();

      // Set theme on page load (saved or auto-detect)
      const savedTheme = localStorage.getItem("theme");
      if (savedTheme) {
        document.documentElement.setAttribute("data-theme", savedTheme);
      } else if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.documentElement.setAttribute("data-theme", "dark");
      } else {
        document.documentElement.setAttribute("data-theme", "light");
      }

      function toggleDarkMode() {
        const currentTheme = document.documentElement.getAttribute("data-theme");
        const newTheme = currentTheme === "dark" ? "light" : "dark";
        document.documentElement.setAttribute("data-theme", newTheme);
        localStorage.setItem("theme", newTheme);
      }

      async function loadWavFiles() {
        const progressBar = document.getElementById("progress-bar");
        progressBar.style.width = "0%";
        try {
          const [wavListResponse, customWavListResponse, groupsMainResponse, groupsCustomResponse] =
            await Promise.all([
              fetch("wav_list.json?v=" + Date.now()),
              fetch("custom_wav_list.json?v=" + Date.now()),
              fetch("groups.json?v=" + Date.now()),
              fetch("groups_custom.json?v=" + Date.now()),
            ]);

          const wavFiles = await wavListResponse.json();
          const customWavFiles = await customWavListResponse.json();
          const groupsMain = await groupsMainResponse.json();
          const groupsCustom = await groupsCustomResponse.json();

          const allFiles = [...wavFiles, ...customWavFiles];
          const allGroups = { ...groupsMain, ...groupsCustom };

          allFiles.sort((a, b) => a.localeCompare(b));

          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          gainNode = audioContext.createGain();
          gainNode.connect(audioContext.destination);

          const volumeSlider = document.getElementById("volume-slider");
          const savedVolume = localStorage.getItem("volumeLevel");
          const initialVolume = savedVolume !== null ? parseInt(savedVolume) : 50;
          volumeSlider.value = initialVolume;
          gainNode.gain.setValueAtTime(initialVolume / 100, audioContext.currentTime);

          volumeSlider.addEventListener("input", function () {
            const volume = parseInt(this.value) / 100;
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            localStorage.setItem("volumeLevel", this.value);
          });

          // ✅ Skip hidden entries and skip loading WAVs up front (lazy load)
          let processed = 0;
          const total = allFiles.length;

          for (const file of allFiles) {
            try {
              const meta = allGroups[file] || {
                group: "Other",
                name: file.split("/").pop(),
                description: "",
                hidden: false,
              };

              // ✅ Skip hidden sounds entirely
              if (meta.hidden) continue;

              soundMeta.push({
                file,
                group: meta.group,
                name: meta.name,
                description: meta.description,
                hidden: false,
              });
              // ✅ Don't fetch or decode anything now (lazy load in startLoop)
              // (soundBuffers[file] will be filled later on-demand)
            } catch (error) {
              console.error(`❌ Failed to process metadata for ${file}:`, error);
              continue;
            } finally {
              processed++;
              progressBar.style.width = `${Math.floor((processed / total) * 100)}%`;
            }
          }

          document.getElementById("audio-list").innerHTML = ""; // Clear 'Loading sounds...'
          const searchTerm = document.getElementById("search-input")?.value?.trim() || "";
          displayGroups(soundMeta, searchTerm);
        } catch (error) {
          console.error("❌ Error loading sound metadata or audio files:", error);
          document.getElementById("audio-list").textContent = "❌ Failed to load sounds.";
        }
        setTimeout(() => {
          document.getElementById("progress-container").style.display = "none";
        }, 300); // fade out after short delay
      }

      function displayGroups(sounds, searchTerm = "") {
        const audioList = document.getElementById("audio-list");
        audioList.innerHTML = "";

        const grouped = {};
        for (const sound of sounds) {
          if (!grouped[sound.group]) {
            grouped[sound.group] = [];
          }
          grouped[sound.group].push(sound);
        }

        for (const groupName of Object.keys(grouped).sort()) {
          // Filter visible sounds
          const visibleSounds = grouped[groupName].filter((sound) => {
            if (sound.hidden) return false;
            const haystack = `${sound.name} ${sound.description}`.toLowerCase();
            return haystack.includes(searchTerm.toLowerCase());
          });

          // Skip group if no visible sounds
          if (visibleSounds.length === 0) continue;

          // Sort visible sounds by their 'name'
          const sortedSounds = visibleSounds.sort((a, b) =>
            a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: "base" })
          );

          const groupTitle = document.createElement("h2");
          groupTitle.className = "group-title";
          groupTitle.textContent = groupName;

          const groupGrid = document.createElement("div");
          groupGrid.className = "audio-grid";

          if (collapsedGroups.includes(groupName)) {
            groupGrid.classList.add("collapsed");
            groupGrid.style.transform = "scaleY(0)";
            groupGrid.style.opacity = "0";
          }

          for (const sound of sortedSounds) {
            const card = document.createElement("div");
            card.className = "audio-card";

            const name = document.createElement("div");
            name.className = "file-name";
            name.textContent = sound.name;

            const desc = document.createElement("div");
            desc.className = "file-description";
            desc.textContent = sound.description || "";

            const buttonGroup = document.createElement("div");
            buttonGroup.className = "button-group";

            const playButton = document.createElement("button");
            playButton.className = "play-button";
            playButton.dataset.file = sound.file;
            playButton.textContent = "Play";

            const stopButton = document.createElement("button");
            stopButton.className = "stop-button";
            stopButton.textContent = "Stop";

            playButton.onclick = () => startLoop(sound.file);
            stopButton.onclick = () => stopLoop(sound.file);

            buttonGroup.appendChild(playButton);
            buttonGroup.appendChild(stopButton);
            card.appendChild(name);
            card.appendChild(desc);
            card.appendChild(buttonGroup);
            groupGrid.appendChild(card);
          }

          groupTitle.addEventListener("click", () => {
            const isCollapsed = groupGrid.classList.contains("collapsed");

            if (!isCollapsed) {
              groupGrid.style.transform = "scaleY(0)";
              groupGrid.style.opacity = "0";
              setTimeout(() => {
                groupGrid.classList.add("collapsed");
                if (!collapsedGroups.includes(groupName)) collapsedGroups.push(groupName);
                localStorage.setItem("collapsedGroups", JSON.stringify(collapsedGroups));
              }, 400);
            } else {
              groupGrid.classList.remove("collapsed");
              groupGrid.style.transform = "scaleY(0)";
              groupGrid.style.opacity = "0";
              requestAnimationFrame(() => {
                groupGrid.style.transform = "scaleY(1)";
                groupGrid.style.opacity = "1";
              });
              collapsedGroups = collapsedGroups.filter((name) => name !== groupName);
              localStorage.setItem("collapsedGroups", JSON.stringify(collapsedGroups));
            }
          });

          audioList.appendChild(groupTitle);
          audioList.appendChild(groupGrid);
        }
      }

      async function startLoop(file) {
        stopLoop(file); // Only stops that sound if already playing

        const btn = document.querySelector(`.play-button[data-file="${file}"]`);
        if (btn) btn.classList.add("loading");

        // Remove from cancel list in case it's replayed manually
        cancelledLoads.delete(file);

        try {
          // Lazy-load if needed
          if (!soundBuffers[file]) {
            const fetchResponse = await fetch(file);
            const arrayBuffer = await fetchResponse.arrayBuffer();

            // Cancelled while loading
            if (cancelledLoads.has(file)) {
              console.log(`❌ Skipped loading ${file} (was cancelled)`);
              if (btn) btn.classList.remove("loading");
              return;
            }

            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            soundBuffers[file] = audioBuffer;
          }
          // Cancelled after decode
          if (cancelledLoads.has(file)) {
            console.log(`❌ Skipped playing ${file} (was cancelled post-decode)`);
            if (btn) btn.classList.remove("loading");
            return;
          }

          const sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = soundBuffers[file];
          sourceNode.loop = true;
          sourceNode.connect(gainNode);
          sourceNode.start(0);
          playingSources.push({ file, node: sourceNode });

          // Mark button as actively playing
          if (btn) {
            btn.classList.remove("loading");
            btn.classList.add("active");
          }
          return Promise.resolve(); // ✅ resolve when playback starts
        } catch (error) {
          console.error(`❌ Error loading or playing ${file}:`, error);
          if (btn) btn.classList.remove("loading", "active");
          return Promise.reject(error);
        }
      }

      function stopLoop(file) {
        playingSources = playingSources.filter((src) => {
          if (src.file === file) {
            try {
              src.node.stop();
              src.node.disconnect();
            } catch (e) {
              console.error(e);
            }
            return false;
          }
          return true;
        });
        document.querySelectorAll(".play-button").forEach((btn) => {
          if (btn.dataset.file === file) {
            btn.classList.remove("active");
            btn.classList.remove("loading");
          }
        });
      }

      function stopAll() {
        playingSources.forEach((src) => {
          try {
            src.node.stop();
            src.node.disconnect();
          } catch (e) {
            console.error(e);
          }
        });

        playingSources = [];

        // ✅ Reset visual buttons
        document.querySelectorAll(".play-button, .global-button").forEach((btn) => {
          btn.classList.remove("active", "loading");
        });

        // ✅ Mark all currently loading sounds as "cancelled"
        soundMeta.forEach((sound) => {
          cancelledLoads.add(sound.file);
        });
      }

      async function playAll() {
        stopAll(); // Clear running sounds
        cancelledLoads.clear(); // ✅ Reset the cancellation list

        const playAllBtn = document.querySelector('button[onclick="playAll()"]');
        if (playAllBtn) {
          playAllBtn.classList.add("loading");
          playAllBtn.disabled = true;
        }

        const promises = soundMeta.map((sound) => startLoop(sound.file));

        try {
          await Promise.all(promises);
          if (playAllBtn) {
            playAllBtn.classList.remove("loading");
            playAllBtn.classList.add("active");
          }
        } catch (err) {
          console.warn("Some sounds failed to load during Play All:", err);
          if (playAllBtn) {
            playAllBtn.classList.remove("loading");
          }
        } finally {
          if (playAllBtn) playAllBtn.disabled = false;
        }
      }

      loadWavFiles();
      document.getElementById("search-input").addEventListener("input", (e) => {
        const value = e.target.value.trim();
        displayGroups(soundMeta, value);
      });

      function expandAllGroups() {
        document.querySelectorAll(".audio-grid").forEach((grid) => {
          grid.classList.remove("collapsed");
          grid.style.transform = "scaleY(0)";
          grid.style.opacity = "0";
          requestAnimationFrame(() => {
            grid.style.transform = "scaleY(1)";
            grid.style.opacity = "1";
          });
        });
        collapsedGroups = [];
        localStorage.setItem("collapsedGroups", "[]");
      }
      function collapseAllGroups() {
        document.querySelectorAll(".audio-grid").forEach((grid) => {
          grid.style.transform = "scaleY(0)";
          grid.style.opacity = "0";
          setTimeout(() => {
            grid.classList.add("collapsed");
          }, 400); // Match your CSS transition time
        });
        collapsedGroups = Array.from(document.querySelectorAll(".group-title")).map((title) =>
          title.textContent.trim()
        );
        localStorage.setItem("collapsedGroups", JSON.stringify(collapsedGroups));
      }
    </script>
  </body>
</html>
